# Docker and Docker Compose configuration
A Dockerfile is a script-like file containing a series of instructions that Docker uses to create an image. It defines the environment and steps required to set up an application. including dependencies, configuration and scripts. Once built, the image is lightweight and isolated.</br>
- `FROM` - specifies the base image used to create the container.
- `USER` - switches the execution context to the specified user.
- `RUN` - executes shell commands to create a new layer in the image.
- `mkdir` - creates a directory with the specified structure.
- `WORKDIR` - sets the working directory for subsequent instructions (if the directory doesn't exist, it is created).
- `COPY` - copies files or directories from the build context into the container's filesystem.
- `apt-get` - a package management tool used in Debian-based Linux distributions to install, update, and manage software packages.
- `rm` - deletes files or directories.
- `EVN` -sets environment variables inside the container, which can be accessed during the container's runtime.
- `REQUESTS_CA_BUNDLE` - a Python requests library-specific environment variable that specifies the path to a custom Certificate Authority (CA) bundle for verifying HTTPS requests.
- `PYTHONWARNINGS` - a Python-specific environment variable that controls how warnings are handled during runtime.
- `ENTRYPOINT` - configures a container to run as an executable. It specifies the command and arguments to be executed when the container starts.
-------------------------------------------------------------------------
Docker Compose is a tool for defining and managing multi-container Docker applications. It allows configuration of multiple services (containers) in a single YAML file.</br>
- `service:` - defines the services.
- `tests:` - name of the service, that you can be use to refer to the container within the Compose file and when interacting with Docker.
- `build:` - builds a service based on the Dockerfile located in the specified directory (`.` current directory).
- `container_name:` - sets the name of the container.
- `depends_on:` - specifies a dependency between services.
- `condition:` - used in conjunction with the `depends_on` directive to control the startup order of services. It can be set to `service_started` or `service_healthy`.
- `environment:` - sets environment variables inside the container.
- `working_dir:` - sets the working directory for subsequent  instructions (if the directory doesn't exist, it is created).
- `volumes:` - mechanism for persisting data generated by and used by Docker containers, shared across containers or saved even if the container is stopped and restarted.
- `.:/opt/project` - mounts the current directory `.` on the host to `/opt/project` inside the container.
- `api_mock_certs:/root/ca/rsa/volumed_dir` - creates a named volume `api_mock_certs` and mounts it to `/root/ca/rsa/volumed_dir` inside the container.
- `entrypoint:` - specifies the command that should be run when the container starts.
- `api-mock:` - name of the service, that you can be use to refer to the container within the Compose file and when interacting with Docker.
- `ports:` - a configuration that accepts `*HOST_PORT*:*CONTAINER_PORT*` form of syntax for the port definition .
- `"8080:80"` - maps port 80 inside the container (the web server's HTTP port) to port 8080 on the host machine
- `"8443:443"` - maps port 443 inside the container (the web server's HTTPS port) to port 8443 on the host machine.
- `volumes:` (outside the `services`) - defines volumes names that can be shared and used by multiple services within the same Compose file.
-------------------------------------------------------------------------
**Understand the services defined in docker-compose.yml.**</br>
- *Tests Service*: Builds from the current directory's Dockerfile, has a `tests-server` name, waits for api-mock to be started before it runs, uses two volumes (for the application code and certificates), and runs a ping command to check if api-mock-server is up before exiting.</br>
- *API Mock Service*: Builds from the same Dockerfile, has the name `api-mock-server`, uses the same volume for certificates, and exposes HTTP and HTTPS ports to the host machine.
-------------------------------------------------------------------------
**Note how the web server is containerized and how it interacts with other services.**</br>
This project simulates an API mock server that handles device inventory and file uploads, responding to HTTP/HTTPS requests. The server is containerized with Docker. The *Dockerfile* starts from `Debian` base image, installs dependencies listed in `debian_packages.txt`, sets `environment variables`, copies `certificates`, the `app folder`, and the `bin folder`, then `runs a script to create certificates`. Finally, the `start.sh` script starts the application. The *docker-compose.yml* defines two services: 
- `api-mock`, which serves the mock data on HTTP (port 8080) and HTTPS (port 8443). 
- `tests`, a service designed to run tests on the `api-mock` server. It depends on the `api-mock` to be up and running before it starts performing tests.
By default, all containers within the same Docker Compose file are part of the same network and can access each other using the service name as the hostname.
-------------------------------------------------------------------------
**Identify the exposed ports and environment variables.**</br>
- *Exposed ports:*
	- `80` (HTTP) mapped to port 8080 on the host machine.
	- `443` (HTTPS) mapped to port 8443 on the host machine.

- *Environment variables:*
	- `REQUESTS_CA_BUNDLE`
	- `PYTHONWARNINGS`
	- `MOCK_HOSTNAME`
# HTTPS and certificates
- `HTTPS` stands for Hypertext Transfer Protocol Secure. It ensures secure communication by encrypting data transferred between a client and a server. 
- `Certificate Validation`: When a client connects to a server over HTTPS, the server sends its certificates (or chain of certidicates). The client verifies the server's certificates to confirm its identity and establish trust.
- `Root CA Certificate` is issued by a trusted Cerfificate Authority (CA) and acts as the foudation of trust.
- `Intermediate CA certificate` is issued by a `Root CA` to an intermediate authority, which then issues certificates to servers. This structure, known as *cerfificate chain*, adds layers of validation, making it easier to revoke or manage certificates if needed.
- `Encryption with Certificates`: After verifying the serverâ€™s certificate, the client generates a random *session key* for encryption. It is securely shared with the server using its certificate. Subsequent communication between the client and server is encrypted using this session key.
- `Self-assigned certificates`: Since the mock API server is using self-assigned certificates for HTTPS, we need to download those certificates and pass them as an argument when sending HTTPS requests.
- `Add HTTPS configuration to Python tests`: The server provides the root and intermediate certificates through endpoints. The client (requests library) must use these certificates to validate the server's identity when calling its HTTPS endpoints.
- `subjectAltName`: This field is used to specify the valid hostnames for the SSL certificate. The `<mock-hostname>` placeholder should be replaced with the actual hostname that matches the server. I've replaced it with `localhost` to run tests against my local machine and `api-mock` to run tests in tests servoce against the api-mock container.
# Database
`mock-database` service is created by using already created PostgreSQL image, sets nesseccary values, states and ports and copies the file that populates the database after the continer is started.  